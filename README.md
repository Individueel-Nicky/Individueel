# Portfolio of my individual work in semester 3
Nicky Tabrizifar
Class: S3-DB01
Teachers: Samuil Angelov and Jean Paul Ligthart

## My Deployed Website
- Vercel: https://nickster.vercel.app/
- Git Repository: https://github.com/nickybreezy/Nickster
- Research Report: https://github.com/nickybreezy/Nickster/blob/main/researchreport.md
---
## Table of contents
- [1. Introduction](#1-introduction)
- [2. Learning Outcomes](#2-learning-outcomes)
- [3. Research](#3-research)
  - [3.1. Cultural differences](#31-cultural-differences)
  - [3.2. Ethics](#32-ethics)
  - [3.3. Agile methods](#33-agile-methods)
  - [3.4. Business processes](#34-business-processes)
  - [3.5. Security Risk: Insecure Design](#35-security-risk-)
- [4. Individual Project (Nickster)](#4-individual-project-)
  - [4.1. Software design](#41-software-design)
  - [4.2. CI/CD](#42-cicd)
  - [4.3. Software Quality](#43-software-quality)
- [5. Group Project (The Parking Pals)](#5-group-project-)
  - [5.1. Software design](#51-software-design)
  - [5.2. CI/CD](#52-cicd)
  - [5.3. Software quality](#53-software-quality)
  - [5.4. UI and UX design](#54-ui-and-ux-design)
- [6. Reflection](#6-reflection)
  - [6.1. What have I learned?](#61-what-i-have-learned)
  - [6.2. What went well?](#62-what-went-well)
  - [6.3. What would I do differently next time?](#63-where-there-is-room-for-improvement)

## 1. Introduction

Welcome to my software development portfolio! I'm currently in my third semester at Fontys ICT & Software Engineering. This portfolio showcases how I have gone through the learning outcomes using my recent work, including research reports, individual and group projects, and reflections on my learning journey. I hope you enjoy reading through my work, and please feel free to contact me if you have any questions or would like to discuss a project.



## 2. Learning Outcomes

| # | Name | Short description | Clarification |
|---|------|-------------------|---------------|
| 1 | Web application | You design and build **user-friendly, full-stack** web applications. | **User friendly:** You apply basic User experience testing and development techniques.<br>**Full-stack:** You design and build a full stack application using commonly accepted front end (JavaScript-based framework) and back end techniques (e.g. Object Relational Mapping) choosing and implementing relevant communication protocols and addressing asynchronous communication issues. |
| 2 | Software quality | You use software **tooling and methodology** that continuously monitors and improve the software quality during software development. | **Tooling and methodology:** Carry out, monitor and report on unit integration, regression and system tests, with attention for security and performance aspects, as well as applying static code analysis and code reviews. |
| 3 | Agile method | You **choose** and implement the most suitable agile software development method for your software project. | **Choose:** You are aware of the most popular agile methods and their underlying agile principles. Your choice of a method is motivated and based on well-defined selection criteria and context analyses. |
| 4 | CI/CD | You **implement** a (semi)automated software release process that matches the needs of the project context. | **Implement:** You implement a continuous integration and deployment solution (using e.g. Gitlab CI and Docker). |
| 5 | Cultural differences and ethics | You **recognize** and **take into account** cultural differences between project stakeholders and ethical aspects in software development. | **Recognize**:  Recognition is based on theoretically substantiated awareness of cultural differences and ethical aspects in software engineering.<br>**Take into account:** Adapt your communication, working, and behavior styles to reflect project stakeholders from different cultures;<br>Address one of the standard Programming Ethical Guidelines (e.g., ACM Code of Ethics and Professional Conduct) in your work. |
| 6 | Requirements and Design | You analyze (non-functional) requirements, elaborate (architectural) designs and validate them using **multiple types of test techniques**. | **Multiple types of test techniques:** You apply user acceptance testing and stakeholder feedback to validate the quality of the requirements. You evaluate the quality of the design (e.g., by testing or prototyping) taking into account the formulated quality properties like security and performance. |
| 7 | Business processes | You analyze and describe **simple** business processes that are **related** to your project. | **Simple:** Involving stakeholders, predominantly sequential processes with one or two alternative paths.<br>**Related:** Business processes during which the software that you are developing will be used (business processes that the software must support by fully or partially automating them).<br>**or**<br>Business processes needed for the success of your software development project (e.g., product release, market release, financial assurance). |
| 8 | Professional | You act in a **professional manner** during software development and learning. | **Professional manner:** You develop software as a team effort according to a prescribed software methodology and following team agreements. You are able to track your work progress and communicate your progress with the team.<br>You actively ask and apply feedback from stakeholders and advise them on the most optimal technical and design (architectural) solutions. You choose and substantiate solutions for a given problem. |

[⬆️ Back to Table of Contents](#table-of-contents)

## 3. Research
Throughout the semester, I delved into various areas of study including new technologies, business processes and methods, cultural differences, ethics, security risks, and prevention methods. Additionally, I emphasized the significance of well-documented projects. My research findings have been compiled into research reports which are available below. By being well-versed in these areas of study and having the ability to conduct research on new subjects, I am able to showcase my mastery of learning outcome 8: Professional.


## 3.1. Cultural differences

### 1. Introduction
Every software engineer must work with others during their career life. Developing strong communication skills is crucial for preventing miscommunications and errors in business operations with different cultures. Effective communication involves active listening, clear articulation of ideas, and adjusting communication style according to the audience. Practicing and refining these skills can enhance an individual's ability to communicate effectively in professional settings and prevent potential mistakes. 

### 2. What is culture?

In the IT world, culture refers to the shared values, beliefs, attitudes, and behaviors that shape the organization's approach to technology and its use. It encompasses factors such as the organization's approach to innovation, collaboration, risk-taking, and adaptability. IT culture can impact the effectiveness and efficiency of technology initiatives and shape the attitudes and behaviors of employees toward technology adoption and use.

### 3.2. Ethics
## 3. Programming Ethical Guidelines 
As a software engineer, I tried as much as possible to implement the following ethical guidelines:

1. Respect privacy: Ensure that the privacy of individuals is protected by implementing security measures that prevent unauthorized access to personal data.

2. Honesty and transparency: Be truthful about the capabilities and limitations of your software, and disclose any potential risks associated with its use.

3. Fairness and non-discrimination: Do not design or implement software that discriminates against individuals based on their race, gender, religion, or any other characteristic.

4. Consider the social impact: Be aware of the potential social impact of your software and take steps to mitigate any negative effects it may have.

5. Respect intellectual property: Do not infringe on the intellectual property rights of others when developing software.

6. Maintain quality: Ensure that your software is of high quality and free of defects that could cause harm or damage to users.

7. Continuous learning and improvement: Stay current with new technologies and best practices in software development, and strive to continuously improve your skills and knowledge.

It is still important to remember that ethics in software engineering is an ongoing process, and engineers should be constantly evaluating and re-evaluating their decisions to ensure that they match with the current ethical principles.

[⬆️ Back to Table of Contents](#table-of-contents)

## 4. Personal experiences with cultural differences

During my first try at the first semester, I had chosen to enroll it in "Course-Based", which therefore meant that I would communicate with different types of cultured students and teachers. 
The aspect which stood out the most was the way we would work on a project, I had mostly dealt with East European students. Most of them had a determined way of doing things their way or it was harder to make sure they would work on the project at most. It took some getting used to at first, but nothing too difficult.

### 3.2. Ethics
Ethics in software engineering refers to the principles and values that guide the behavior of software developers and the software they produce. Software engineers have a responsibility to design, build, and maintain software that is safe, secure, reliable, and efficient. They must also consider the impact of their software on society and the environment.
Programming Ethical Guidelines 
As a software engineer, I tried as much as possible to implement the following ethical guidelines:

1. Respect privacy: Ensure that the privacy of individuals is protected by implementing security measures that prevent unauthorized access to personal data.

2. Honesty and transparency: Be truthful about the capabilities and limitations of your software, and disclose any potential risks associated with its use.

3. Fairness and non-discrimination: Do not design or implement software that discriminates against individuals based on their race, gender, religion, or any other characteristic.

4. Consider the social impact: Be aware of the potential social impact of your software and take steps to mitigate any negative effects it may have.

5. Respect intellectual property: Do not infringe on the intellectual property rights of others when developing software.

6. Maintain quality: Ensure that your software is of high quality and free of defects that could cause harm or damage to users.

7. Continuous learning and improvement: Stay current with new technologies and best practices in software development, and strive to continuously improve your skills and knowledge.

It is still important to remember that ethics in software engineering is an ongoing process, and engineers should be constantly evaluating and re-evaluating their decisions to ensure that they match with the current ethical principles.

### Why are ethics important in software engineering?
Software engineering ethics are essential for many reasons. As software engineers have a significant impact on people's lives, users must trust that the software they use is reliable, safe, and secure. Adhering to ethical principles is crucial as it builds trust and credibility with users and stakeholders, and the lack of it could lead to legal and financial consequences. Ethical considerations help software engineers make responsible decisions that minimize harm to users or society. In addition, ethical software engineering practices ensure that software has a positive impact on society and the environment. Ultimately, upholding ethics is a crucial element of professionalism that helps to guarantee software's safety, reliability, and trustworthiness, which in turn contributes to the betterment of society.

### What do you have to do as a software engineer to address ethical aspects in your work?
As a software engineer, addressing ethical aspects in your work requires several steps. Firstly, you must educate yourself on ethical issues related to software engineering such as algorithmic bias, data privacy, and cybersecurity. Secondly, consider the potential impacts of your work on different stakeholders, including end-users, society, and the environment. You must also follow ethical design principles and ensure that your software respects user privacy, ensures fairness, and non-discrimination. Thirdly, participate in ethical discussions with colleagues and stakeholders to raise concerns and collaborate on ethical solutions. Finally, if you become aware of any ethical concerns related to your work, take responsibility for addressing them by reporting them to relevant authorities and working to find ethical solutions. By following these steps, you can address ethical aspects in your work and ensure that your software development process is ethical and responsible.

## 2. Ethics analysis for group project
>iets hier schrijven over dat we de boven aspecten toegoevoegd hebben in ons project.waar het project ethisch voor bedoeld is.

>vertel hier wat voor data we van ons gebruikers verzamelen en of we hun probert zo secure mogelijk te blijven en wat voor authentication (tokens) we stellen

>vertel hier hoe we alles testen met disrupties, wat ons ci/cd pipeline is en hoe toegankelijk onze code is evt. 

[⬆️ Back to Table of Contents](#table-of-contents)

### 2.1 Ethical conflicts & soltions
Ethical conflicts for The Parking Pals may occur in a few occasions. The most important one, is when the user is obligated to give their license plate number so that it can be registered in the system. Nevertheless, this information is considered to be sensitive personal data, and it would therefore be very important to handle this information carefully and securely so as not to risk the privacy of our users. VUL OPLOSSING HIER

>talk about another conflict, eg when a user doesnt actually go to the space they reserved for, 

### 3. Ethics analysis for individual project
> hetzelfde als voor groep


### 3.3. Agile methods

#### What is Agile?
Agile is a term that describes approaches to software development that emphasize incremental delivery, team collaboration, continual planning, and continual learning. The different methodologies are used to establish different principles to guide a better approach to software development.

1. Customer satisfaction: Agile focuses on delivering value to the customer, and customer satisfaction is a top priority.

2. Flexibility: Agile methodologies prioritize flexibility and adaptability to change, which is achieved through an iterative approach to development.

3. Collaboration: Agile encourages close collaboration among team members, customers, and stakeholders, with a focus on open communication and collaboration.

4. Continuous improvement: Agile methodologies prioritize continuous improvement through regular reviews and retrospectives to identify areas for improvement.

5. Transparency: Agile encourages transparency in all aspects of development, with an emphasis on open communication and clear documentation.

6. Iterative development: Agile methodologies are based on an iterative approach to development, with frequent feedback and testing to ensure that the product meets the customer's needs.

7. Self-organizing teams: Agile methodologies rely on self-organizing teams that are empowered to make decisions and collaborate to achieve their goals.

#### Scrum
Scrum is a popular Agile methodology used for software development and project management. It has become widely adopted because it offers several advantages over other methodologies. Scrum is mostly considered 'better' for the cause that it is way more flexible in adapting to changing requirements, and the ability to respond quickly to customer needs.
Secondly it also is very 'handy' because it makes sure both the customers and stakeholders are involved in the project. 


    Continuous Improvement: Scrum encourages continuous improvement by reviewing progress regularly and adapting the development approach accordingly.

    Focus on teamwork: Scrum is built on the principle of teamwork, with a focus on empowering teams to make decisions, collaborate, and achieve their goals.

    Efficient project management: Scrum offers a structured approach to project management, with clear roles and responsibilities for team members, regular meetings, and clear goals.

    Faster Time-to-Market: Scrum's iterative approach to development enables teams to deliver working software in short iterations, which can help bring products to market faster.

However, it is important to note that Scrum may not be the best fit for every project. Each methodology has its own strengths and weaknesses, and the choice of methodology should be based on the specific requirements and characteristics of the project.

<p align="center">
  <img src="https://th.bing.com/th/id/R.3896712f25b01b9a774a1d62798d4616?rik=hYV21pkHGoBYDg&riu=http%3a%2f%2fprojektwelten.projectplant.de%2fwp-content%2fuploads%2f2016%2f07%2fProjectPlant_ScrumMethode_Ueberblick.jpg&ehk=CWYVNaQXNpwqRs%2fRcabXxRcRU3lktrbwjrkjc3vB8So%3d&risl=&pid=ImgRaw&r=0" width="300" alt="Scrum">
</p>


#### Kanban
Kanban and Scrum are both popular Agile methodologies used for software development and project management. Each methodology has its own strengths and weaknesses, and the choice of methodology should be based on the specific requirements and characteristics of the project. Here are some reasons why Kanban may be considered better than Scrum in certain situations:

    Flexibility: Kanban offers a high degree of flexibility, allowing teams to make changes and adjustments to the process as needed.

    Focus on Flow: Kanban is focused on optimizing the flow of work through the system, which can help identify bottlenecks and areas for improvement.

    Reduced waste: Kanban emphasizes reducing waste in the system, which can help teams be more efficient and reduce costs.

    Minimal overhead: Kanban has minimal overhead, which can be advantageous for small teams or projects with low complexity.

    Continuous delivery: Kanban enables continuous delivery by allowing teams to release features as soon as they are ready, which can help bring products to market faster.

However, it is important to note that Scrum may be a better fit for projects that require more structure, regularity, and predictability. Scrum has a more defined framework and provides a clear set of roles, events, and artifacts, which can be advantageous for larger or more complex projects. Ultimately, the choice of methodology should be based on the specific needs and goals of the project, as well as the preferences and capabilities of the team.

#### For the group project
At first, we took in consideration what kind of customers will be using our application and asked ourselves two questions, “Do our customers want to decide what gets done and when?” and the answer to that is that their choice should be somewhat flexible. Following that the next aspect we investigated was how often the team want to review tasks and plan the project further, we concluded that every two weeks at most would be the best also seeing that Scrum is a method all of us have used before. So, the conclusion was that the Scrum method had our best interest. 

Scrum (vs other methodologies) 
Scrum project management is an Agile method that focuses on ordering tasks to complete projects more quickly while Kanban is primarily more focused on process improvements. 

#### For my individual project
Personally I have only worked with Scrum and I kept finding it the most compatible to my work processes. I used a simple board project from GitHub to accomplish this.

## 5. Group Project (The Parking Pals)
>insert logo here

A company that owns parking garages gets a lot of complaints about the malfunctioning of the ticket machines. They also receive complaints about the queue being too long for machines, so you must wait a long time to pay. The client wishes for a solution to their previously mentioned problem. The preferred solution would make it so that the driver of the vehicle can drive into the parking garage without having to stand still. This would be possible by registering the license plate of the vehicle. The driver would then be able to pay via his/her mobile device so that they can leave the garage. It would reduce the amount of time a driver takes to park his/her vehicle in the garage and the same applies to leaving the garage. This would allow an increased traffic flow in and out of the garage and would therefore allow for an increased revenue stream. It would also provide a more convenient solution for the driver, which would result in a better reputation compared to alternative parking solutions. 

[Azure DevOps for the process](https://dev.azure.com/parking-pals/Parking%20Pals%20App/_sprints/taskboard/Parking%20Pals%20App%20Team/Parking%20Pals%20App/)

>add a gif quickly showing the website

### 5.1 Strategy
At first, we took in consideration what kind of customers will be using our application and asked ourselves two questions, “Do our customers want to decide what gets done and when?” and the answer to that is that their choice should be somewhat flexible. Following that the next aspect we investigated was how often the team want to review tasks and plan the project further, we concluded that every two weeks at most would be the best also seeing that Scrum is a method all of us have used before. So, the conclusion was that the Scrum method had our best interest. 
Scrum project management is an Agile method that focuses on ordering tasks to complete projects more quickly while Kanban is primarily more focused on process improvements. 

### 5.2 Design choice
- Front end, React  

For the learning outcomes, it is specified that we use a JavaScript front-end framework. We chose React since we already have some experience with React. It has a wide range of documentation and many job opportunities, as it is a very popular framework now. 

- Back end, C# Asp.net 

Because we worked previously with C#, and because C# outperforms Java while having the same functionalities. We have selected C# Asp.net 

### 5.3 Software Design

#### Software Architecture
<p align="center">
  <img src="[https://th.bing.com/th/id/R.3896712f25b01b9a774a1d62798d4616?rik=hYV21pkHGoBYDg&riu=http%3a%2f%2fprojektwelten.projectplant.de%2fwp-content%2fuploads%2f2016%2f07%2fProjectPlant_ScrumMethode_Ueberblick.jpg&ehk=CWYVNaQXNpwqRs%2fRcabXxRcRU3lktrbwjrkjc3vB8So%3d&risl=&pid=ImgRaw&r=0](https://camo.githubusercontent.com/966bcef2778f624c6fc5ef8b7c2a7f5c6f11a2defb1c70ae7e7357f47777dd99/68747470733a2f2f692e6962622e636f2f734372364d68672f636f6e7461696e65722d6d6f64656c2e706e67)" width="300" alt="Architecture Design">
</p>

The Parking Pal application has been set up as a microservices architecture. This means the application is comprised of building a server application as a set of small services. Advantages of this approach are that it improves maintainability and testability, is independently deployable and scalable and it facilitates easy integration of multiple technologies. Communication between front-end and back-end will be performed through REST and WebSocket protocols.
As to be seen in the image, it has a lot of services, each to have their own api to easily have the CRUD operations.

Each service has its own database and if it needs data from outside its domain to perform its function, it will contact the relevant service through the API gateway and request the needed data from the service that contains it. We have tried to minimize these dependencies in order to keep the different services as independent of each other as possible. In case the client application needs to collect data from the different domains it can contact each service separately to request the required data, combine it, and display it to the user.

> Add the configured/latest architecture at the end of the project when everything is done 
